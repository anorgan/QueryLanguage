<?php

namespace Anorgan\QueryLanguage\Parser;

/**
 * Generated by PHPUnit_SkeletonGenerator on 2014-10-24 at 00:57:35.
 */
class QueryParserTest extends \PHPUnit_Framework_TestCase
{

    /**
     * @var QueryParser
     */
    protected $object;
    
    /**
     *
     * @var QueryLexer
     */
    protected $lexer;
    

    /**
     * Sets up the fixture, for example, opens a network connection.
     * This method is called before a test is executed.
     */
    protected function setUp()
    {
        $this->lexer  = new QueryLexer;
        $this->object = new QueryParser($this->lexer);
    }

    /**
     * @covers Anorgan\QueryLanguage\Parser\QueryParser
     * @dataProvider dataProviderTestParse
     */
    public function testParse($inputQuery, $expectedQuery)
    {
        $this->assertEquals($expectedQuery, (string) $this->object->parse($inputQuery));
    }

    /**
     * @return array
     */
    public function dataProviderTestParse()
    {
        $data = [];

        $i = 0;
        
        $data['simple query' . $i++] = [
            'input'     => 'alfa=beta',
            'expected'  => 'alfa=beta'
        ];

        $data['simple query with array value' . $i++] = [
            'input'     => 'alfa.beta = [a, b, c]',
            'expected'  => 'alfa.beta=["a","b","c"]'
        ];
        
        $data['simple query quoted' . $i++] = [
            'input'     => 'a="b"',
            'expected'  => 'a=b'
        ];

        $data['simple query, value has space' . $i++] = [
            'input'     => 'field>="some value"',
            'expected'  => 'field>=some value'
        ];

        $data['simple query, value has escaped quote w\o space' . $i++] = [
            'input'     => 'field<="some\"value\""',
            'expected'  => 'field<=some"value"'
        ];

        $data['simple query, value has escaped quote with space' . $i++] = [
            'input'     => 'some.field<>"some \"value\""',
            'expected'  => 'some.field!=some "value"'
        ];

        $data['complex query with AND' . $i++] = [
            'input'     => 'Parent.Relation.field != "174 systems" AND some_field > 13',
            'expected'  => '(Parent.Relation.field!=174 systems) AND (some_field>13)'
        ];

        $data['complex query with OR' . $i++] = [
            'input'     => 'Parent.Relation.field != "174 systems" OR is_active < "2014-01-01"',
            'expected'  => 'Parent.Relation.field!=174 systems OR is_active<2014-01-01'
        ];

// Problems with ConditionalPrimary returning query that gets passed to Query::add
//        $data['complex query with both AND and OR' . $i++] = [
//            'input'     => '(Parent.Relation.field != "174 systems") OR (is_active < "2014-01-01" AND true!=false)',
//            'expected'  => 'Parent.Relation.field!=174 systems OR (is_active<2014-01-01 AND true!=false)'
//        ];
//
//        $data['conditional primary' . $i++] = [
//            'input'     => '(Parent.Relation.field != "174 systems") AND (is_active < "2014-01-01" AND true!=false)',
//            'expected'  => 'Parent.Relation.field!=174 systems OR (is_active<2014-01-01 AND true!=false)'
//        ];


        return $data;
    }

    /**
     * @expectedException \Exception
     * @expectedExceptionMessage Error matching token, expecting test
     * @covers Anorgan\QueryLanguage\Parser\QueryParser::match
     */
    public function testMatchThrowsExceptionIfLookaheadTypeDoesNotMatch()
    {
        $this->object->match("test");
    }

    /**
     * @expectedException \Exception
     * @expectedExceptionMessage Error matching comparison operator, expecting one of: =, :, <, <=, >, >=, !=, got no operator
     * @covers Anorgan\QueryLanguage\Parser\QueryParser::ComparisonOperator
     */
    public function testComparisonOperatorThrowsExceptionIfThereIsNoMatch()
    {
        $this->lexer->lookahead['value'] = 'no operator';
        $this->object->ComparisonOperator();
    }

    /**
     * @expectedException \Exception
     * @expectedExceptionMessage Error, expecting Literal, got fake type
     * @covers Anorgan\QueryLanguage\Parser\QueryParser::Literal
     */
    public function testLiteralThrowsExceptionIfTokenIsOfWrongType()
    {
        $this->lexer->lookahead['type'] = 'fake type';
        $this->lexer->token['value'] = 'fake type';
        $this->object->Literal();
    }
}
